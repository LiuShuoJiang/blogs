---
# type: docs 
title: C++程序执行的核心内容
date: 2023-11-12T19:24:42-05:00
featured: false
draft: true
comment: true
toc: true
reward: true
pinned: false
carousel: false
series:
categories: []
tags: []
images: []
---

程序的执行

<!--more-->

## 进程的虚拟地址空间内存划分及布局

任何编程语言在代码运行时会产生两样东西：指令和数据。

运行时，可执行程序会从磁盘上加载到内存中，实际上不可能直接加载到物理内存中！

默认x86 32位的Linux环境下，Linux系统会给当前进程分配一个 $2^{32}$ 大小(4G)的一块空间，称为 **进程的虚拟地址空间**。

它存在，你能看得见，它是物理的；它存在，你看不见，它是透明的；它不存在，你却看得见，它是虚拟的；它不存在，你也看不见，它被删除了。

进程的虚拟地址空间被划分为两个部分：

- **用户空间**(User Space)：占3G
  - 从`0x00000000`开始到`0x08048000`：预留
  - 从`0x08048000`开始到`0xC0000000`：
    - `.text`段(代码区)用来存储代码；`.rodata`段(只读数据段)，例如常量字符串
    - `.data`段：存储已初始化且初始化值不为0的数据
    - `.bss`段：存储未初始化或初始化值为0的数据，操作系统对`.bss`段数据初始化为0
    - `.heap`段(堆内存)：当程序动态分配内存时才有该空间，从低地址到高地址增长
    - 加载的共享库：如`*.dll`, `*.so`文件
    - `stack`(栈空间)：栈从上往下增长
    - 命令行参数和环境变量
- **内核空间**(Kernel Space)：占1G
  - 从`0xC0000000`开始到`0xFFFFFFFF`：
    - `ZONE_DMA`
    - `ZONE_NORMAL`
    - `ZONE_HIGHMEM`

注：局部非静态变量编译后产生的指令被放在`.text`段，指令运行时会在栈空间分配数据。

每一个进程的用户空间是私有的，但内核空间是共享的。

***匿名管道通信***是进程之间的通信方式的一种。

## 函数的调用堆栈过程

esp存储当前函数栈帧栈顶的位置，ebp存储main函数栈帧栈底的位置。

函数调用时形参变量的内存是调用方函数开辟的。
